\section{Solved problems}
\subsection{DatabaseFacade dependencies}

\begin{enumerate}
\item \emph{InternetFrontEnd.init()}: load properties (dbUser, dbPassword and
    dbUrl) from the configuration file (\emph{web\_portal.cfg}) and pass them to
    \emph{ApplicationFacade}
    
\item \emph{ApplicationFacade} pass the properties to \emph{DatabaseFacade}

\item \emph{DatabaseFacade} pass the properties to \emph{UserDatabase},
    \emph{RegularDatabase} and \emph{RawDatabase}
\end{enumerate}

The problem with the process described above is that properties which are SQL
related are retrieved at the presentation level and then explicitely given to
the logic level and finally to the database level. ``The database layer
interface should be generic, and not expose the specific requirements of the
layer'' (cf subject).
We would like to use other databases (e.g. JSON) than SQL ones, so we need to
remove or modify these dependencies from DatabaseFacade. The configuration need
to be retrieved from InternetFacade and given to the database layer by passing
trough the application layer, so, instead of passing the individual properties
as parameters, we can pass the \emph{Properties} object holding all properties.
It can then be passed to the 3 different databases (user, regular and raw).

The properties related to SQL in \emph{web\_portal.cfg} were modified to the
following name pattern: dbSQL* (e.g. dbUser -> dbSQLUser).
\newpage

\subsection{Databases}

\emph{Database}, \emph{RawDatabase}, \emph{RegularDatabase} and
\emph{UserDatabase} are all related to an SQL database. We would like to
add a database based on the JSON format. We need to rename the
previously cited class to show their real use (and move them into a
separate package).

\begin{itemize}
    \item \emph{Database} -> \emph{SQLDatabase}
    \item \emph{RawDatabase} -> \emph{RawSQLDatabase}
    \item \emph{RegularDatabase} -> \emph{RegularSQLDatabase}
    \item \emph{UserDatabase} -> \emph{UserSQLDatabase}
\end{itemize}

Then, we need to create interfaces which will be implemented by the databases we
need (e.g. \emph{SQLRawDatabase} implements the \emph{RawDatabase} interface).

Finally, we must be able to switch the type of database by modifying a property
(\emph{dbType}) in the \emph{web\_portal.cfg} file.
The database type can be tested to decide which classes to instantiate in
\emph{DatabaseFacade}. However, each time we want to add a type of
database in the application we also need to add it in the long \emph{if..else}
of the \emph{DatabaseFacade} constructor which can be seen below.

\begin{lstlisting}
if (dbType.equals("SQL")) {
	userDb		= new UserSQLDatabase(properties);
	regularDb	= new RegularSQLDatabase(properties);
	rawDb		= new RawSQLDatabase(properties);
} else if (dbType.equals("JSON")) {
    ...
}
\end{lstlisting}

These conditions can be moved outside to avoid having a huge constructor.
An Abstract Factory pattern was used, which may be a bit overkill in this case
(but it was a real application of this pattern and I wanted to try it).

\begin{lstlisting}
public interface AbstractDatabaseFactory {
	public RawDatabase getRawDatabase(Properties properties);
	public RegularDatabase getRegularDatabase(Properties properties);
	public UserDatabase getUserDatabase(Properties properties);
}

public class DatabaseFactoryProducer {
	
	/**
	 * Get a factory based on the type of database we want to use.
	 * @param type of database
	 * @return database factory for the selected type of database
	 */
	public static AbstractDatabaseFactory getFactory(String type) {
		if (type.equals("SQL")) {
			return new SQLDatabaseFactory();
		}
		
		return null;
	}
}

public class SQLDatabaseFactory implements AbstractDatabaseFactory {

	public RawDatabase getRawDatabase(Properties properties) {
		return new RawSQLDatabase(properties);
	}

	public RegularDatabase getRegularDatabase(Properties properties) {
		return new RegularSQLDatabase(properties);
	}

	public UserDatabase getUserDatabase(Properties properties) {
		return new UserSQLDatabase(properties);
	}

}

public DatabaseFacade(Properties properties) {
	String dbType = properties.getProperty("dbType");
	AbstractDatabaseFactory df = DatabaseFactoryProducer.getFactory(dbType);
	
	userDb    = df.getUserDatabase(properties);
	regularDb = df.getRegularDatabase(properties);
	rawDb     = df.getRawDatabase(properties);
}
\end{lstlisting}

Here we only have two databases implementations, but should the number grow
quickly, a more dynamic solution would be to use reflection. However using
reflection has an impact on performances and should be used as a last resort.

% TODO insert diagram

\newpage

\subsection{UserProfile \& subclasses}

\emph{ExpensiveSubscription}, \emph{CheapSubscription},
\emph{FreeSubscription}, \emph{ExpertAdministator},
\emph{ExternalAdministrator}, \emph{RegularAdministrator} and
\emph{Operator} contain a lot of code duplication (constructors,
\emph{asSql()}, \emph{asSqlUpdate()} and \emph{asXml()}), only a few strings
are different.

First, the \emph{getType()} abstract method was added to the \emph{UserProfile}.
All its subclasses need to implement it by indicating the type of user.
It will be used further below as an uniform way to know where the data must be
added.

\begin{lstlisting}
public class UserProfile extends Data {
    ...
    protected abstract String getType();
    ...
}

public class CheapSubscription extends RegularUser {
    ...
    
    @Override
	protected String getType() {
		return "CheapSubscription";
	}
    ...
}
\end{lstlisting}

With the \emph{getType()} method we can modify and move the \emph{asSql()},
\emph{asSqlUpdate()}, and \emph{asXml()} methods from the subclasses to
\emph{UserProfile}. The constructors can also be moved.

\begin{lstlisting}
public class UserProfile extends Data {
	public UserProfile(HttpServletRequest request) { ... }
    public UserProfile(ResultSet rs) throws SQLException, ParseException {
        ...
    }
    public UserProfile(String username, String password, String firstName,
		String lastName, String emailAddress, Date lastLogin)
    { ... }
        
    public String asXml() {
		return	"<" + getType() + ">" +
			"<username>" + normalizeXml(username) + "</username>" +
			// password is not returned,
			// as it should only be used internally
			"<firstName>" +
			normalizeXml(firstName) +
			"</firstName>" +
			"<lastName>" + normalizeXml(lastName) + "</lastName>" +
			"<emailAddress>" +
			normalizeXml(emailAddress) +
			"</emailAddress>" +
			"<lastLogin>" + df.format(lastLogin) + "</lastLogin>" +
			"</" + getType() + ">";
	}

	/**
	 * Returns an SQL INSERT string that allows the system to add
	 * the account to a relational database.
	 */
	public String asSql() {
		return	"INSERT INTO " + getType() + " (Username, " +
			"Password, FirstName, LastName, EmailAddress, " +
			"LastLogin) VALUES (\'" + normalizeSql(username) +
			"\', \'" + normalizeSql(password) +"\', \'" +
			normalizeSql(firstName) + "\', \'" +
			normalizeSql(lastName) + "\', \'" +
			normalizeSql(emailAddress) + "\', \'" +
			df.format(lastLogin) + "\');";
	}

	/**
	 * Returns an SQL UPDATE string that allows the system to update
	 * the account in a relational database.
	 */
	public String asSqlUpdate() {
		return  "UPDATE " + getType() + " SET Password = \'" +
			normalizeSql(password) + "\', FirstName = \'" +
			normalizeSql(firstName) + "\', LastName = \'" +
			normalizeSql(lastName) + "\', EmailAddress = \'" +
			normalizeSql(emailAddress) + "\', LastLogin = \'" +
			df.format(lastLogin) + "\' " + "WHERE Username = \'" +
			normalizeSql(username) + "\';";
	}
}
\end{lstlisting}

\subsubsection{Type refactoring}

\subsection{JSONDatabase implementation}

\subsubsection{First implementation}

\subsubsection{Second implementation}

\newpage
